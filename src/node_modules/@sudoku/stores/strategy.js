import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
import { referenceGrid,userGrid,PossibleNumberGrid } from '@sudoku/stores/grid'

//根据行、列、box获得可能的单元格的值
export function PossibleNumber(){
    // Helper function to get all numbers in a row
    function getRow(sudoku, row) {
        return sudoku[row];
    }

    // Helper function to get all numbers in a column
    function getCol(sudoku, col) {
        return sudoku.map(row => row[col]);
    }

    // Helper function to get all numbers in a 3x3 box
    function getBox(sudoku, row, col) {
        const box = [];
        const startRow = row - row % BOX_SIZE;
        const startCol = col - col % BOX_SIZE;
        for (let r = 0; r < BOX_SIZE; r++) {
            for (let c = 0; c < BOX_SIZE; c++) {
                box.push(sudoku[startRow + r][startCol + c]);
            }
        }
        return box;
    }

    function getPossibleNumbers(sudoku, row, col) {
        const usedNumbers = new Set([
            ...getRow(sudoku, row),
            ...getCol(sudoku, col),
            ...getBox(sudoku, row, col)
        ]);
        const possibleNumbers = [];
        for (let num = 1; num <= SUDOKU_SIZE; num++) {
            if (!usedNumbers.has(num)) {
                possibleNumbers.push(num);
            }
        }
        return possibleNumbers;
    }

    const newReferenceGrid = [
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
    ];

    function getReferenceGrid(sudoku,rowIndex, colIndex){
        //row
        for (let num = 0; num < SUDOKU_SIZE; num++) {
            if (sudoku[rowIndex][num] != 0) {
                // referenceGrid.add([rowIndex,colIndex],[rowIndex,num])
                newReferenceGrid[rowIndex][colIndex].push([rowIndex,num]);
            }
        } 

        //col
        for (let num = 0; num < SUDOKU_SIZE; num++) {
            if (sudoku[num][colIndex] != 0) {
                newReferenceGrid[rowIndex][colIndex].push([num,colIndex])
            }
        } 

        //box
        const startRow = rowIndex - rowIndex % BOX_SIZE;
        const startCol = colIndex - colIndex % BOX_SIZE;
        for (let r = 0; r < BOX_SIZE; r++) {
            for (let c = 0; c < BOX_SIZE; c++) {
            const value = sudoku[startRow + r][startCol + c];
            if (value !== 0) {
                // referenceGrid.add([rowIndex, colIndex], [startRow + r, startCol + c]);
                newReferenceGrid[rowIndex][colIndex].push([startRow + r, startCol + c])
            }
            }
        }
        return newReferenceGrid;
    }

    let newPossibleGrid;

    userGrid.subscribe($userGrid=>{

        newPossibleGrid = $userGrid.map((row, rowIndex) =>
            row.map((cell, colIndex) => {
                if (cell === 0) {
                    return getPossibleNumbers($userGrid, rowIndex, colIndex);
                } else {
                    return [];
                }
            })
        );

        // PossibleNumberGrid.set(newPossibleGrid);

        newPossibleGrid.forEach((row, rowIndex) => {
            row.forEach((cell, colIndex) => {
            if (cell.length > 0) {
                getReferenceGrid($userGrid, rowIndex, colIndex);
            }
            });
        });

    })
    // console.log(newPossibleGrid)
    // console.log(newReferenceGrid)
    return [newPossibleGrid,newReferenceGrid,"PossibleNumber"];
}



//两个单元格中的两个候选数的集合，它们至少共属于一个单元。

export function NakedPairs() {

    let newPossibleNumberGrid = [
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
	];

    let newReferenceGrid = [
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
	];

    function findNakedPairs(cells) {
        const pairs = [];
        const pairMap = new Map();

        cells.forEach((cell, index) => {
            if (cell.length === 2) {
                const key = cell.join(',');
                if (pairMap.has(key)) {
                    pairs.push([pairMap.get(key), index]);
                } else {
                    pairMap.set(key, index);
                }
            }
        });

        return pairs;
    }

    function removeNakedPairs(cells, pairs) {
        pairs.forEach(([index1, index2]) => {
            const [num1, num2] = cells[index1];
            cells.forEach((cell, index) => {
                if (index !== index1 && index !== index2) {
                    const newCell = cell.filter(num => num !== num1 && num !== num2);
                    cells[index] = newCell;
                }
            });
        });
    }

    function processNakedPairs(grid) {
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            // 行
            const row = grid[i];
            const rowPairs = findNakedPairs(row);
            removeNakedPairs(row, rowPairs);

            // 列
            const col = grid.map(row => row[i]);
            const colPairs = findNakedPairs(col);
            col.forEach((cell, index) => {
                grid[index][i] = cell; // 更新原始 grid 的列
            });
            removeNakedPairs(col, colPairs);

            // 宫格
            const box = [];
            const startRow = Math.floor(i / BOX_SIZE) * BOX_SIZE;
            const startCol = (i % BOX_SIZE) * BOX_SIZE;
            for (let r = 0; r < BOX_SIZE; r++) {
                for (let c = 0; c < BOX_SIZE; c++) {
                    box.push(grid[startRow + r][startCol + c]);
                }
            }
            const boxPairs = findNakedPairs(box);
            removeNakedPairs(box, boxPairs);
            box.forEach((cell, index) => {
                const r = Math.floor(index / BOX_SIZE);
                const c = index % BOX_SIZE;
                grid[startRow + r][startCol + c] = cell; // 更新原始 grid 的宫格
            });
        }
        return grid;
    }

    function updateReferenceGrid(possibleNumberGrid) {
        // const newReferenceGrid = referenceGrid.map(row => row.map(cell => [...cell]));

        for (let rowIndex = 0; rowIndex < SUDOKU_SIZE; rowIndex++) {
            for (let colIndex = 0; colIndex < SUDOKU_SIZE; colIndex++) {
                if (possibleNumberGrid[rowIndex][colIndex].length > 0) {
                    const candidates = possibleNumberGrid[rowIndex][colIndex];
                    for (let i = 0; i < SUDOKU_SIZE; i++) {
                        if (i !== colIndex && candidates.some(num => possibleNumberGrid[rowIndex][i].includes(num))) {
                            newReferenceGrid[rowIndex][colIndex].push([rowIndex, i]);
                        }
                        if (i !== rowIndex && candidates.some(num => possibleNumberGrid[i][colIndex].includes(num))) {
                            newReferenceGrid[rowIndex][colIndex].push([i, colIndex]);
                        }
                    }
                    const startRow = rowIndex - rowIndex % BOX_SIZE;
                    const startCol = colIndex - colIndex % BOX_SIZE;
                    for (let r = 0; r < BOX_SIZE; r++) {
                        for (let c = 0; c < BOX_SIZE; c++) {
                            const value = possibleNumberGrid[startRow + r][startCol + c];
                            if (value.some(num => candidates.includes(num)) && (startRow + r !== rowIndex || startCol + c !== colIndex)) {
                                newReferenceGrid[rowIndex][colIndex].push([startRow + r, startCol + c]);
                                newReferenceGrid[rowIndex][colIndex].push([startRow + r, startCol + c]);
                            }
                        }
                    }
                }
            }
        }

        return newReferenceGrid;
    }

    PossibleNumberGrid.subscribe($possibleNumberGrid=>{
        newPossibleNumberGrid = JSON.parse(JSON.stringify($possibleNumberGrid));
        // console.log($possibleNumberGrid)
        newPossibleNumberGrid = processNakedPairs(newPossibleNumberGrid);
    })
    // console.log(newPossibleNumberGrid)
    newReferenceGrid = updateReferenceGrid(newPossibleNumberGrid);

    return [ newPossibleNumberGrid, newReferenceGrid,"NakedPairs"];
}