import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
import { referenceGrid,userGrid } from '@sudoku/stores/grid'
import { derived, writable } from 'svelte/store';

export const strategyMap = new Map();
strategyMap.set('PossibleNumber', PossibleNumber);
strategyMap.set('NakedPairs', NakedPairs);
strategyMap.set('HiddenPairs', HiddenPairs);
strategyMap.set('XWing', XWing);
// strategyMap.set('YWing', YWing);

class Strategy{ //基类
    constructor(possibleNumberGrid = []){
        this.newPossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid));
        this.newReferenceGrid = Array.from({ length: SUDOKU_SIZE }, () => Array.from({ length: SUDOKU_SIZE }, () => []));
        this.strategy = "";
    }
}

class PossibleNumberStrategy extends Strategy{

}

//根据行、列、box获得可能的单元格的值
export function PossibleNumber(){
    // Helper function to get all numbers in a row
    function getRow(sudoku, row) {
        return sudoku[row];
    }

    // Helper function to get all numbers in a column
    function getCol(sudoku, col) {
        return sudoku.map(row => row[col]);
    }

    // Helper function to get all numbers in a 3x3 box
    function getBox(sudoku, row, col) {
        const box = [];
        const startRow = row - row % BOX_SIZE;
        const startCol = col - col % BOX_SIZE;
        for (let r = 0; r < BOX_SIZE; r++) {
            for (let c = 0; c < BOX_SIZE; c++) {
                box.push(sudoku[startRow + r][startCol + c]);
            }
        }
        return box;
    }

    function getPossibleNumbers(sudoku, row, col) {
        let usedNumbers = new Set([
            ...getRow(sudoku, row),
            ...getCol(sudoku, col),
            ...getBox(sudoku, row, col)
        ]);
        let possibleNumbers = [];
        for (let num = 1; num <= 9; num++) {
            if (!usedNumbers.has(num)) {
                possibleNumbers.push(num);
            }
        }
        return possibleNumbers;
    }

    const newReferenceGrid = [
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
    ];

    function getReferenceGrid(sudoku,rowIndex, colIndex){
        //row
        for (let num = 0; num < SUDOKU_SIZE; num++) {
            if (sudoku[rowIndex][num] != 0) {
                // referenceGrid.add([rowIndex,colIndex],[rowIndex,num])
                newReferenceGrid[rowIndex][colIndex].push([rowIndex,num]);
            }
        } 

        //col
        for (let num = 0; num < SUDOKU_SIZE; num++) {
            if (sudoku[num][colIndex] != 0) {
                newReferenceGrid[rowIndex][colIndex].push([num,colIndex])
            }
        } 

        //box
        const startRow = rowIndex - rowIndex % BOX_SIZE;
        const startCol = colIndex - colIndex % BOX_SIZE;
        for (let r = 0; r < BOX_SIZE; r++) {
            for (let c = 0; c < BOX_SIZE; c++) {
            const value = sudoku[startRow + r][startCol + c];
            if (value !== 0) {
                // referenceGrid.add([rowIndex, colIndex], [startRow + r, startCol + c]);
                newReferenceGrid[rowIndex][colIndex].push([startRow + r, startCol + c])
            }
            }
        }
        return newReferenceGrid;
    }

    let newPossibleGrid;

    userGrid.subscribe($userGrid=>{

        newPossibleGrid = $userGrid.map((row, rowIndex) =>
            row.map((cell, colIndex) => {
                if (cell === 0) {
                    return getPossibleNumbers($userGrid, rowIndex, colIndex);
                } else {
                    return [];
                }
            })
        );

        // console.log(newPossibleGrid)
        // PossibleNumberGrid.set(newPossibleGrid);

        newPossibleGrid.forEach((row, rowIndex) => {
            row.forEach((cell, colIndex) => {
            if (cell.length > 0) {
                getReferenceGrid($userGrid, rowIndex, colIndex);
            }
            });
        });

    })
    // console.log(newReferenceGrid)
    // console.log(JSON.parse(JSON.stringify(newPossibleGrid)))

    return [newPossibleGrid,newReferenceGrid,"PossibleNumber"];
}



//两个单元格中的两个候选数的集合，它们至少共属于一个单元。

export function NakedPairs(possibleNumberGrid) {

    let newPossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid));

    let newReferenceGrid = Array.from({ length: SUDOKU_SIZE }, () => Array.from({ length: SUDOKU_SIZE }, () => []));

    function findNakedPairs(cells) {
        const pairs = [];
        const pairMap = new Map();

        cells.forEach((cell, index) => {
            if (cell.length === 2) {
                const key = cell.join(',');
                if (pairMap.has(key)) {
                    pairMap.get(key).push(index);

                } else {
                    pairMap.set(key, [index]);
                }
            }
        });

        pairMap.forEach((value, key) => {
            if (value.length === 2) {
                pairs.push(value);
            }
        });

        return pairs;

    }

    function removeNakedPairs(cells, pairs) {
        const executed = []
        pairs.forEach(([index1, index2]) => {
            const [num1, num2] = cells[index1];
            cells.forEach((cell, index) => {
                if (index !== index1 && index !== index2) {
                    const newCell = cell.filter(num => num !== num1 && num !== num2);
                    cells[index] = newCell;
                    executed.push([index,index1,index2]);
                }
            });
        });
        return executed
    }

    function processNakedPairs(grid,reference) {
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            // 行
            const row = grid[i];
            const rowPairs = findNakedPairs(row);
            const rowexecuted = removeNakedPairs(row, rowPairs);
            rowexecuted.forEach(([executedIndex,index1,index2]) => {
                reference[i][executedIndex].push([i,index1],[i,index2]);
            });
            row.forEach((cell, index) => {
                grid[i][index] = cell; // 更新原始 grid 的行
            });

            // 列
            const col = grid.map(row => row[i]);
            const colPairs = findNakedPairs(col);
            const colexecuted = removeNakedPairs(col, colPairs);
            colexecuted.forEach(([executedIndex,index1,index2]) => {
                reference[executedIndex][i].push([index1,i],[index2,i]);
            });
            col.forEach((cell, index) => {
                grid[index][i] = cell; // 更新原始 grid 的列
            });

            // 宫格
            const box = [];
            const startRow = Math.floor(i / BOX_SIZE) * BOX_SIZE;
            const startCol = (i % BOX_SIZE) * BOX_SIZE;
            for (let r = 0; r < BOX_SIZE; r++) {
                for (let c = 0; c < BOX_SIZE; c++) {
                    box.push(grid[startRow + r][startCol + c]);
                }
            }
            const boxPairs = findNakedPairs(box);
            const boxexecuted = removeNakedPairs(box, boxPairs);
            boxexecuted.forEach(([executedIndex,index1,index2]) => {
                const r = Math.floor(executedIndex / BOX_SIZE);
                const c = executedIndex % BOX_SIZE;
                const r1 = Math.floor(index1 / BOX_SIZE);
                const c1 = index1 % BOX_SIZE;
                const r2 = Math.floor(index2 / BOX_SIZE);
                const c2 = index2 % BOX_SIZE;
                reference[startRow + r][startCol + c].push([startRow + r1, startCol + c1],[startRow + r2, startCol + c2]);
            });
            box.forEach((cell, index) => {
                const r = Math.floor(index / BOX_SIZE);
                const c = index % BOX_SIZE;
                grid[startRow + r][startCol + c] = cell; // 更新原始 grid 的宫格
            });
        }
        return [grid,reference];
    }

        // console.log($possibleNumberGrid)
    [newPossibleNumberGrid,newReferenceGrid] = processNakedPairs(newPossibleNumberGrid,newReferenceGrid);
    // console.log(newPossibleNumberGrid)
    
    return [ newPossibleNumberGrid, newReferenceGrid,"NakedPairs"];
}

export function HiddenPairs(possibleNumberGrid){

    let newPossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid));

    let newReferenceGrid = Array.from({ length: SUDOKU_SIZE }, () => Array.from({ length: SUDOKU_SIZE }, () => []));

    function findHiddenPairs(cells) {
        const pairs = [];
        const candidadtes = new Map();
        const pairMap = new Map();

        cells.forEach((cell, index) => {
            cell.forEach(num => {
                if (!pairMap.has(num)) {
                    pairMap.set(num, []);
                }
                pairMap.get(num).push(index);
            });
        });

        pairMap.forEach((indices,key) => {
            if (indices.length === 2) {
                const indexkey = indices.join(',');
                if(candidadtes.has(indexkey)){
                    candidadtes.get(indexkey).push(parseInt(key));
                }else{
                    candidadtes.set(indexkey,[parseInt(key)]);
                }
                // const [index1, index2] = indices;
                // candidadtes.push([index1,index2,parseInt(key)])
                // const commonNums = cells[index1].filter(n => cells[index2].includes(n) && cells.filter(cell => cell.includes(n)).length === 2);
                // if (commonNums.length === 2) {
                //     pairs.push([index1, index2, commonNums[0], commonNums[1]]);
                // }
            }
        });

        candidadtes.forEach((nums,indices) => {
            if(nums.length === 2){
                pairs.push(indices.split(',').map(index => parseInt(index)).concat(nums));
            }
        });

        console.log(pairs)
        return pairs;

    }

    function removeHiddenPairs(cells, pairs) {
        const executed = []
        pairs.forEach(([index1, index2, num1, num2]) => {
            // const [num1, num2] = cells[index1];
            const newCell1 = cells[index1].filter(num => num == num1 || num == num2);
            const newCell2 = cells[index2].filter(num => num == num1 || num == num2);
            cells[index1] = newCell1
            cells[index2] = newCell2
            executed.push([index1,index2])
            // cells.forEach((cell, index) => {
            //     if (index !== index1 && index !== index2) {
            //         const newCell = cell.filter(num => num !== num1 && num !== num2);
            //         cells[index] = newCell;
            //         executed.push([index1,index2]);
            //     }
            // });
        });
        return executed
    }

    function processHiddenPairs(grid,reference) {
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            // 行
            const row = grid[i];
            const rowPairs = findHiddenPairs(row);
            const rowexecuted = removeHiddenPairs(row, rowPairs);
            rowexecuted.forEach(([index1,index2]) => {
                reference[i][index1].push([i,index2]);
                reference[i][index2].push([i,index1]);
            });
            row.forEach((cell, index) => {
                grid[i][index] = cell; // 更新原始 grid 的行
            });

            // 列
            const col = grid.map(row => row[i]);
            const colPairs = findHiddenPairs(col);
            const colexecuted = removeHiddenPairs(col, colPairs);
            colPairs.forEach(([index1,index2]) => {
                reference[index1][i].push([index2,i]);
                reference[index2][i].push([index1,i]);
            });
            col.forEach((cell, index) => {
                grid[index][i] = cell; // 更新原始 grid 的列
            });

            // 宫格
            const box = [];
            const startRow = Math.floor(i / BOX_SIZE) * BOX_SIZE;
            const startCol = (i % BOX_SIZE) * BOX_SIZE;
            for (let r = 0; r < BOX_SIZE; r++) {
                for (let c = 0; c < BOX_SIZE; c++) {
                    box.push(grid[startRow + r][startCol + c]);
                }
            }
            const boxPairs = findHiddenPairs(box);
            const boxexecuted = removeHiddenPairs(box, boxPairs);
            boxexecuted.forEach(([index1,index2]) => {
                const r1 = Math.floor(index1 / BOX_SIZE);
                const c1 = index1 % BOX_SIZE;
                const r2 = Math.floor(index2 / BOX_SIZE);
                const c2 = index2 % BOX_SIZE;
                reference[startRow + r1][startCol + c1].push([startRow + r2, startCol + c2]);
                reference[startRow + r2][startCol + c2].push([startRow + r1, startCol + c1]);
            });
            box.forEach((cell, index) => {
                const r = Math.floor(index / BOX_SIZE);
                const c = index % BOX_SIZE;
                grid[startRow + r][startCol + c] = cell; // 更新原始 grid 的宫格
            });
        }
        return [grid,reference];
    }

    [newPossibleNumberGrid,newReferenceGrid] = processHiddenPairs(newPossibleNumberGrid,newReferenceGrid);


    return [newPossibleNumberGrid, newReferenceGrid, "HiddenPairs"];
    
}

export function XWing(possibleNumberGrid){

    let newPossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid));

    let newreferencegrid = Array.from({ length: SUDOKU_SIZE }, () => Array.from({ length: SUDOKU_SIZE }, () => [])); // 初始化三维数组

    // 遍历 1 到 9 的数字
    for (let num = 1; num <= 9; num++) {
        // 查找符合 X-Wing 条件的行对
        for (let row1 = 0; row1 < SUDOKU_SIZE; row1++) {
            for (let row2 = row1 + 1; row2 < SUDOKU_SIZE; row2++) {
                let cols1 = [];
                let cols2 = [];

                // 查找该行中含有 num 的候选位置
                for (let col = 0; col < SUDOKU_SIZE; col++) {
                    if (possibleNumberGrid[row1][col].includes(num)) {
                        cols1.push(col);
                    }
                    if (possibleNumberGrid[row2][col].includes(num)) {
                        cols2.push(col);
                    }
                }

                // 如果行1和行2中，num的候选列数都正好为2，且这两个列集合相等，说明找到了 X-Wing 模式
                if (cols1.length === 2 && cols2.length === 2 && cols1.toString() === cols2.toString()) {
                    // 应用 X-Wing 排除策略
                    for (let r = 0; r < 9; r++) {
                        if (r !== row1 && r !== row2) {
                            cols1.forEach(col => {
                                if (newPossibleNumberGrid[r][col].includes(num)) {
                                    newPossibleNumberGrid[r][col] = newPossibleNumberGrid[r][col].filter(val => val !== num);
                                    // 记录参考坐标
                                    newreferencegrid[r][col].push([row1, col]);
                                    newreferencegrid[r][col].push([row2, col]);
                                }
                            });
                        }
                    }
                }
            }
        }

        // 查找符合 X-Wing 条件的列对
        for (let col1 = 0; col1 < SUDOKU_SIZE; col1++) {
            for (let col2 = col1 + 1; col2 < SUDOKU_SIZE; col2++) {
                let rows1 = [];
                let rows2 = [];

                // 查找该列中含有 num 的候选位置
                for (let row = 0; row < SUDOKU_SIZE; row++) {
                    if (possibleNumberGrid[row][col1].includes(num)) {
                        rows1.push(row);
                    }
                    if (possibleNumberGrid[row][col2].includes(num)) {
                        rows2.push(row);
                    }
                }

                // 如果列1和列2中，num的候选行数都正好为2，且这两个行集合相等，说明找到了 X-Wing 模式
                if (rows1.length === 2 && rows2.length === 2 && rows1.toString() === rows2.toString()) {
                    // 应用 X-Wing 排除策略
                    for (let c = 0; c < SUDOKU_SIZE; c++) {
                        if (c !== col1 && c !== col2) {
                            rows1.forEach(row => {
                                if (newPossibleNumberGrid[row][c].includes(num)) {
                                    newPossibleNumberGrid[row][c] = newPossibleNumberGrid[row][c].filter(val => val !== num);
                                    // 记录参考坐标
                                    newreferencegrid[row][c].push([row, col1]);
                                    newreferencegrid[row][c].push([row, col2]);
                                }
                            });
                        }
                    }
                }
            }
        }
    }


    return [newPossibleNumberGrid, newreferencegrid, "XWing"];    
}

export function YWing(possibleNumberGrid){
    let newpossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid));

    let newreferencegrid = Array.from({ length: SUDOKU_SIZE }, () => Array.from({ length: SUDOKU_SIZE }, () => []));

    function IsSameArea(r1,c1,r2,c2){
        return ((Math.floor(r1 / BOX_SIZE) === Math.floor(r2 / BOX_SIZE) && Math.floor(c1 / BOX_SIZE) === Math.floor(c2 / BOX_SIZE)) || (r1 === r2 || c1 === c2) && !(r1 === r2 && c1 === c2));
    }

    for (let num = 1; num <= 9; num++) {
        // 查找符合 Y-Wing 条件的中心单元格
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (possibleNumberGrid[row][col].length === 2 && possibleNumberGrid[row][col].includes(num)) {
                    // 中心单元格的候选值
                    let candidates = possibleNumberGrid[row][col];
                    let remainingValue = candidates.find(c => c !== num); // 获取与num不同的候选值

                    // 寻找符合条件的端点单元格
                    for (let r1 = 0; r1 < 9; r1++) {
                        for (let c1 = 0; c1 < 9; c1++) {
                            // 端点单元格1，它的候选值应为 "A" 和 "C"
                            if ((IsSameArea(row,col,r1,c1)) && possibleNumberGrid[r1][c1].length === 2 && (possibleNumberGrid[r1][c1].includes(remainingValue))) {
                                let otherCandidates1 = possibleNumberGrid[r1][c1];
                                let commonValue = otherCandidates1.find(c => c !== remainingValue); // 获取剩下的候选值

                                for (let r2 = 0; r2 < 9; r2++) {
                                    for (let c2 = 0; c2 < 9; c2++) {
                                        // 端点单元格2，它的候选值应为 "B" 和 "C"
                                        if ((IsSameArea(row,col,r2,c2)) && (r2 !== r1 && c2 !== c1) && (!IsSameArea(r1,c1,r2,c2)) && possibleNumberGrid[r2][c2].length === 2 && possibleNumberGrid[r2][c2].includes(num) && possibleNumberGrid[r2][c2].includes(commonValue)) {
                                            
                                            {
                                                // 计算这两个端点单元格所在的 box 区域
                                                let box1RowStart = Math.floor(r1 / BOX_SIZE) * BOX_SIZE;
                                                let box2RowStart = Math.floor(r2 / BOX_SIZE) * BOX_SIZE;
                                                let box1ColStart = Math.floor(c1 / BOX_SIZE) * BOX_SIZE;
                                                let box2ColStart = Math.floor(c2 / BOX_SIZE) * BOX_SIZE;

                                                // 计算共同的 box 区域,不包含中心单元格
                                                let boxcommon1RowStart = Math.max(box1RowStart, box2RowStart);
                                                let boxcommon2RowStart = Math.min(box1RowStart,box2RowStart)
                                                let boxcommon1ColStart = Math.max(box1ColStart, box2ColStart);
                                                let boxcommon2ColStart = Math.min(box1ColStart,box2ColStart)

                                               let boxcommonRowStart,boxcommonColStart;

                                               if((boxcommon1RowStart === Math.floor(row / BOX_SIZE) * BOX_SIZE) && (boxcommon1ColStart === Math.floor(col / BOX_SIZE) * BOX_SIZE)){
                                                boxcommonRowStart = boxcommon2RowStart;
                                                boxcommonColStart = boxcommon2ColStart;
                                            }else{
                                                boxcommonRowStart = boxcommon1RowStart;
                                                boxcommonColStart = boxcommon1ColStart;
                                            }


                                                // 排除共享候选值C在box区域内的所有出现，且不包含中心单元格
                                                for (let i = boxcommonRowStart; i < boxcommonRowStart + BOX_SIZE; i++) {
                                                    for (let j = boxcommonColStart; j < boxcommonColStart + BOX_SIZE; j++) {
                                                        // 在 box 区域内排除共享值 C，且不包含中心单元格
                                                            if((i != r1 || j != c1) && (i != r2 || j != c2) && newpossibleNumberGrid[i][j].includes(commonValue
                                                            )){
                                                                newpossibleNumberGrid[i][j] = newpossibleNumberGrid[i][j].filter(val => val != commonValue);
                                                                newreferencegrid[i][j].push([r1, c1], [r2, c2],[row,col]); // 记录参考坐标
                                                            }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }


    return [newpossibleNumberGrid, newreferencegrid, "YWing"];
}
