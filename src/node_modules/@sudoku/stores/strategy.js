import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
import { referenceGrid,userGrid,PossibleNumberGrid } from '@sudoku/stores/grid'
import { derived, writable } from 'svelte/store';

export const strategyMap = new Map();

//根据行、列、box获得可能的单元格的值
export function PossibleNumber(){
    // Helper function to get all numbers in a row
    function getRow(sudoku, row) {
        return sudoku[row];
    }

    // Helper function to get all numbers in a column
    function getCol(sudoku, col) {
        return sudoku.map(row => row[col]);
    }

    // Helper function to get all numbers in a 3x3 box
    function getBox(sudoku, row, col) {
        const box = [];
        const startRow = row - row % BOX_SIZE;
        const startCol = col - col % BOX_SIZE;
        for (let r = 0; r < BOX_SIZE; r++) {
            for (let c = 0; c < BOX_SIZE; c++) {
                box.push(sudoku[startRow + r][startCol + c]);
            }
        }
        return box;
    }

    function getPossibleNumbers(sudoku, row, col) {
        let usedNumbers = new Set([
            ...getRow(sudoku, row),
            ...getCol(sudoku, col),
            ...getBox(sudoku, row, col)
        ]);
        let possibleNumbers = [];
        for (let num = 1; num <= 9; num++) {
            if (!usedNumbers.has(num)) {
                possibleNumbers.push(num);
            }
        }
        return possibleNumbers;
    }

    const newReferenceGrid = [
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
    ];

    function getReferenceGrid(sudoku,rowIndex, colIndex){
        //row
        for (let num = 0; num < SUDOKU_SIZE; num++) {
            if (sudoku[rowIndex][num] != 0) {
                // referenceGrid.add([rowIndex,colIndex],[rowIndex,num])
                newReferenceGrid[rowIndex][colIndex].push([rowIndex,num]);
            }
        } 

        //col
        for (let num = 0; num < SUDOKU_SIZE; num++) {
            if (sudoku[num][colIndex] != 0) {
                newReferenceGrid[rowIndex][colIndex].push([num,colIndex])
            }
        } 

        //box
        const startRow = rowIndex - rowIndex % BOX_SIZE;
        const startCol = colIndex - colIndex % BOX_SIZE;
        for (let r = 0; r < BOX_SIZE; r++) {
            for (let c = 0; c < BOX_SIZE; c++) {
            const value = sudoku[startRow + r][startCol + c];
            if (value !== 0) {
                // referenceGrid.add([rowIndex, colIndex], [startRow + r, startCol + c]);
                newReferenceGrid[rowIndex][colIndex].push([startRow + r, startCol + c])
            }
            }
        }
        return newReferenceGrid;
    }

    let newPossibleGrid;

    userGrid.subscribe($userGrid=>{

        newPossibleGrid = $userGrid.map((row, rowIndex) =>
            row.map((cell, colIndex) => {
                if (cell === 0) {
                    return getPossibleNumbers($userGrid, rowIndex, colIndex);
                } else {
                    return [];
                }
            })
        );

        // console.log(newPossibleGrid)
        // PossibleNumberGrid.set(newPossibleGrid);

        newPossibleGrid.forEach((row, rowIndex) => {
            row.forEach((cell, colIndex) => {
            if (cell.length > 0) {
                getReferenceGrid($userGrid, rowIndex, colIndex);
            }
            });
        });

    })
    // console.log(newReferenceGrid)
    // console.log(JSON.parse(JSON.stringify(newPossibleGrid)))
    strategyMap.set('PossibleNumber', PossibleNumber);

    return [newPossibleGrid,newReferenceGrid,"PossibleNumber"];
}



//两个单元格中的两个候选数的集合，它们至少共属于一个单元。

export function NakedPairs(possibleNumberGrid) {

    let newPossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid));

    let newReferenceGrid = [
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
	];

    function findNakedPairs(cells) {
        const pairs = [];
        const pairMap = new Map();

        cells.forEach((cell, index) => {
            if (cell.length === 2) {
                const key = cell.join(',');
                if (pairMap.has(key)) {
                    pairs.push([pairMap.get(key), index]);
                } else {
                    pairMap.set(key, index);
                }
            }
        });

        return pairs;
    }

    function removeNakedPairs(cells, pairs) {
        pairs.forEach(([index1, index2]) => {
            const [num1, num2] = cells[index1];
            cells.forEach((cell, index) => {
                if (index !== index1 && index !== index2) {
                    const newCell = cell.filter(num => num !== num1 && num !== num2);
                    cells[index] = newCell;
                }
            });
        });
    }

    function processNakedPairs(grid) {
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            // 行
            const row = grid[i];
            const rowPairs = findNakedPairs(row);
            removeNakedPairs(row, rowPairs);

            // 列
            const col = grid.map(row => row[i]);
            const colPairs = findNakedPairs(col);
            col.forEach((cell, index) => {
                grid[index][i] = cell; // 更新原始 grid 的列
            });
            removeNakedPairs(col, colPairs);

            // 宫格
            const box = [];
            const startRow = Math.floor(i / BOX_SIZE) * BOX_SIZE;
            const startCol = (i % BOX_SIZE) * BOX_SIZE;
            for (let r = 0; r < BOX_SIZE; r++) {
                for (let c = 0; c < BOX_SIZE; c++) {
                    box.push(grid[startRow + r][startCol + c]);
                }
            }
            const boxPairs = findNakedPairs(box);
            removeNakedPairs(box, boxPairs);
            box.forEach((cell, index) => {
                const r = Math.floor(index / BOX_SIZE);
                const c = index % BOX_SIZE;
                grid[startRow + r][startCol + c] = cell; // 更新原始 grid 的宫格
            });
        }
        return grid;
    }

    function updateReferenceGrid(possibleNumberGrid) {
        // const newReferenceGrid = referenceGrid.map(row => row.map(cell => [...cell]));

        for (let rowIndex = 0; rowIndex < SUDOKU_SIZE; rowIndex++) {
            for (let colIndex = 0; colIndex < SUDOKU_SIZE; colIndex++) {
                if (possibleNumberGrid[rowIndex][colIndex].length > 0) {
                    const candidates = possibleNumberGrid[rowIndex][colIndex];
                    for (let i = 0; i < SUDOKU_SIZE; i++) {
                        if (i !== colIndex && candidates.some(num => possibleNumberGrid[rowIndex][i].includes(num))) {
                            newReferenceGrid[rowIndex][colIndex].push([rowIndex, i]);
                        }
                        if (i !== rowIndex && candidates.some(num => possibleNumberGrid[i][colIndex].includes(num))) {
                            newReferenceGrid[rowIndex][colIndex].push([i, colIndex]);
                        }
                    }
                    const startRow = rowIndex - rowIndex % BOX_SIZE;
                    const startCol = colIndex - colIndex % BOX_SIZE;
                    for (let r = 0; r < BOX_SIZE; r++) {
                        for (let c = 0; c < BOX_SIZE; c++) {
                            const value = possibleNumberGrid[startRow + r][startCol + c];
                            if (value.some(num => candidates.includes(num)) && (startRow + r !== rowIndex || startCol + c !== colIndex)) {
                                newReferenceGrid[rowIndex][colIndex].push([startRow + r, startCol + c]);
                            }
                        }
                    }
                }
            }
        }

        return newReferenceGrid;
    }
        // console.log($possibleNumberGrid)
    newPossibleNumberGrid = processNakedPairs(newPossibleNumberGrid);
    // console.log(newPossibleNumberGrid)
    newReferenceGrid = updateReferenceGrid(newPossibleNumberGrid);

    strategyMap.set('NakedPairs', NakedPairs);
    
    return [ newPossibleNumberGrid, newReferenceGrid,"NakedPairs"];
}

export function HiddenPairs(possibleNumberGrid){

    let newPossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid));

    let newReferenceGrid = [
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
	];

    // 用于找到单元格中的隐藏对
    function findHiddenPairsInUnit(unitCells, newPossibleNumberGrid) {
        // 用于记录每个候选数字出现的位置
        let candidatePositions = new Map();

        let temp = [
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
        ];


        // 遍历单元格，记录每个数字在哪些格子中是候选数字
        unitCells.forEach(([row, col]) => {
            if (newPossibleNumberGrid[row][col].length > 0) {  // 只处理空格子
                newPossibleNumberGrid[row][col].forEach(num => {
                    if (!candidatePositions.has(num)) {
                        candidatePositions.set(num, [[row, col]]);
                    } else {
                        candidatePositions.get(num).push([row, col]);
                }
            });
            }
        });

                // 查找隐藏对（出现两次的候选数字）
        candidatePositions.forEach((positions, num) => {
            if (positions.length === 2) {
                positions.forEach(([row, col]) => {
                    // 只保留这个隐藏对的数字
                    temp[row][col].push(num)
                });
            }
        });
        
        unitCells.forEach(([row, col]) => {
            if (temp[row][col].length == 2) {
                newPossibleNumberGrid[row][col].length = 0
                temp[row][col].forEach(num => {
                    newPossibleNumberGrid[row][col].push(num);
            });
            }
        });

        return newPossibleNumberGrid;

    }
    

        // 对每一行、列和3x3小方格应用 Hidden Pairs 策略
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            // 对第i行处理
            const rowCells = Array.from({ length: SUDOKU_SIZE }, (_, col) => [i, col]);
            newPossibleNumberGrid = findHiddenPairsInUnit(rowCells,newPossibleNumberGrid);
            // 对第i列处理
            const colCells = Array.from({ length: SUDOKU_SIZE }, (_, row) => [row, i]);
            newPossibleNumberGrid =  findHiddenPairsInUnit(colCells,newPossibleNumberGrid);

            // 对第i个3x3小方格处理
            const startRow = Math.floor(i / BOX_SIZE) * BOX_SIZE;
            const startCol = (i % BOX_SIZE) * BOX_SIZE;
            const boxCells = [];
            for (let r = 0; r < BOX_SIZE; r++) {
                for (let c = 0; c < BOX_SIZE; c++) {
                    boxCells.push([startRow + r, startCol + c]);
                }
            }
            newPossibleNumberGrid = findHiddenPairsInUnit(boxCells,newPossibleNumberGrid);
        }

    strategyMap.set('HiddenPairs', HiddenPairs);
    return [newPossibleNumberGrid, newReferenceGrid, "HiddenPairs"];
    
}

export function XWing(possibleNumberGrid){

    let newPossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid));

    let newReferenceGrid = [
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
	];

    // Helper function to find X-Wing pattern in rows or columns
    function findXWing(isRow) {
        for (let num = 1; num <= 9; num++) {
            let lines = [];
            for (let i = 0; i < 9; i++) {
                let positions = [];
                for (let j = 0; j < 9; j++) {
                    let row = isRow ? i : j;
                    let col = isRow ? j : i;
                    if (PossibleNumberGrid[row][col].includes(num)) {
                        positions.push(isRow ? col : row);
                    }
                }
                if (positions.length === 2) {
                    lines.push({ index: i, positions });
                }
            }
            if (lines.length >= 2) {
                for (let a = 0; a < lines.length - 1; a++) {
                    for (let b = a + 1; b < lines.length; b++) {
                        if (lines[a].positions[0] === lines[b].positions[0] && lines[a].positions[1] === lines[b].positions[1]) {
                            let pos1 = lines[a].positions[0];
                            let pos2 = lines[a].positions[1];
                            for (let k = 0; k < 9; k++) {
                                if (k !== lines[a].index && k !== lines[b].index) {
                                    let row1 = isRow ? lines[a].index : pos1;
                                    let col1 = isRow ? pos1 : lines[a].index;
                                    let row2 = isRow ? lines[b].index : pos2;
                                    let col2 = isRow ? pos2 : lines[b].index;
                                    newPossibleGrid[row1][col1] = newPossibleGrid[row1][col1].filter(n => n !== num);
                                    newPossibleGrid[row2][col2] = newPossibleGrid[row2][col2].filter(n => n !== num);
                                    newReferenceGrid[row1][col1] = [lines[a].index, lines[b].index];
                                    newReferenceGrid[row2][col2] = [lines[a].index, lines[b].index];
                                }
                            }
                        }
                    }
                }
            }
        }
    }


    // Find X-Wing patterns in rows and columns
    findXWing(true);
    findXWing(false);

    return [newPossibleNumberGrid, newReferenceGrid, "XWing"];    
}