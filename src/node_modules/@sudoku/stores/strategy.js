import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
import { referenceGrid,userGrid } from '@sudoku/stores/grid'
import { derived, writable } from 'svelte/store';

export const strategyMap = new Map();
strategyMap.set('PossibleNumber', PossibleNumber);
strategyMap.set('NakedPairs', NakedPairs);
strategyMap.set('HiddenPairs', HiddenPairs);
strategyMap.set('XWing', XWing);
// strategyMap.set('YWing', YWing);

//根据行、列、box获得可能的单元格的值
export function PossibleNumber(){
    // Helper function to get all numbers in a row
    function getRow(sudoku, row) {
        return sudoku[row];
    }

    // Helper function to get all numbers in a column
    function getCol(sudoku, col) {
        return sudoku.map(row => row[col]);
    }

    // Helper function to get all numbers in a 3x3 box
    function getBox(sudoku, row, col) {
        const box = [];
        const startRow = row - row % BOX_SIZE;
        const startCol = col - col % BOX_SIZE;
        for (let r = 0; r < BOX_SIZE; r++) {
            for (let c = 0; c < BOX_SIZE; c++) {
                box.push(sudoku[startRow + r][startCol + c]);
            }
        }
        return box;
    }

    function getPossibleNumbers(sudoku, row, col) {
        let usedNumbers = new Set([
            ...getRow(sudoku, row),
            ...getCol(sudoku, col),
            ...getBox(sudoku, row, col)
        ]);
        let possibleNumbers = [];
        for (let num = 1; num <= 9; num++) {
            if (!usedNumbers.has(num)) {
                possibleNumbers.push(num);
            }
        }
        return possibleNumbers;
    }

    const newReferenceGrid = [
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
        [[], [], [], [], [], [], [], [], []],
    ];

    function getReferenceGrid(sudoku,rowIndex, colIndex){
        //row
        for (let num = 0; num < SUDOKU_SIZE; num++) {
            if (sudoku[rowIndex][num] != 0) {
                // referenceGrid.add([rowIndex,colIndex],[rowIndex,num])
                newReferenceGrid[rowIndex][colIndex].push([rowIndex,num]);
            }
        } 

        //col
        for (let num = 0; num < SUDOKU_SIZE; num++) {
            if (sudoku[num][colIndex] != 0) {
                newReferenceGrid[rowIndex][colIndex].push([num,colIndex])
            }
        } 

        //box
        const startRow = rowIndex - rowIndex % BOX_SIZE;
        const startCol = colIndex - colIndex % BOX_SIZE;
        for (let r = 0; r < BOX_SIZE; r++) {
            for (let c = 0; c < BOX_SIZE; c++) {
            const value = sudoku[startRow + r][startCol + c];
            if (value !== 0) {
                // referenceGrid.add([rowIndex, colIndex], [startRow + r, startCol + c]);
                newReferenceGrid[rowIndex][colIndex].push([startRow + r, startCol + c])
            }
            }
        }
        return newReferenceGrid;
    }

    let newPossibleGrid;

    userGrid.subscribe($userGrid=>{

        newPossibleGrid = $userGrid.map((row, rowIndex) =>
            row.map((cell, colIndex) => {
                if (cell === 0) {
                    return getPossibleNumbers($userGrid, rowIndex, colIndex);
                } else {
                    return [];
                }
            })
        );

        // console.log(newPossibleGrid)
        // PossibleNumberGrid.set(newPossibleGrid);

        newPossibleGrid.forEach((row, rowIndex) => {
            row.forEach((cell, colIndex) => {
            if (cell.length > 0) {
                getReferenceGrid($userGrid, rowIndex, colIndex);
            }
            });
        });

    })
    // console.log(newReferenceGrid)
    // console.log(JSON.parse(JSON.stringify(newPossibleGrid)))

    return [newPossibleGrid,newReferenceGrid,"PossibleNumber"];
}



//两个单元格中的两个候选数的集合，它们至少共属于一个单元。

export function NakedPairs(possibleNumberGrid) {

    let newPossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid));

    let newReferenceGrid = [
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
	];

    function findNakedPairs(cells) {
        const pairs = [];
        const pairMap = new Map();

        cells.forEach((cell, index) => {
            if (cell.length === 2) {
                const key = cell.join(',');
                if (pairMap.has(key)) {
                    pairs.push([pairMap.get(key), index]);
                } else {
                    pairMap.set(key, index);
                }
            }
        });

        return pairs;
    }

    function removeNakedPairs(cells, pairs) {
        pairs.forEach(([index1, index2]) => {
            const [num1, num2] = cells[index1];
            cells.forEach((cell, index) => {
                if (index !== index1 && index !== index2) {
                    const newCell = cell.filter(num => num !== num1 && num !== num2);
                    cells[index] = newCell;
                }
            });
        });
    }

    function processNakedPairs(grid) {
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            // 行
            const row = grid[i];
            const rowPairs = findNakedPairs(row);
            removeNakedPairs(row, rowPairs);

            // 列
            const col = grid.map(row => row[i]);
            const colPairs = findNakedPairs(col);
            col.forEach((cell, index) => {
                grid[index][i] = cell; // 更新原始 grid 的列
            });
            removeNakedPairs(col, colPairs);

            // 宫格
            const box = [];
            const startRow = Math.floor(i / BOX_SIZE) * BOX_SIZE;
            const startCol = (i % BOX_SIZE) * BOX_SIZE;
            for (let r = 0; r < BOX_SIZE; r++) {
                for (let c = 0; c < BOX_SIZE; c++) {
                    box.push(grid[startRow + r][startCol + c]);
                }
            }
            const boxPairs = findNakedPairs(box);
            removeNakedPairs(box, boxPairs);
            box.forEach((cell, index) => {
                const r = Math.floor(index / BOX_SIZE);
                const c = index % BOX_SIZE;
                grid[startRow + r][startCol + c] = cell; // 更新原始 grid 的宫格
            });
        }
        return grid;
    }

    function updateReferenceGrid(possibleNumberGrid) {
        // const newReferenceGrid = referenceGrid.map(row => row.map(cell => [...cell]));

        for (let rowIndex = 0; rowIndex < SUDOKU_SIZE; rowIndex++) {
            for (let colIndex = 0; colIndex < SUDOKU_SIZE; colIndex++) {
                if (possibleNumberGrid[rowIndex][colIndex].length > 0) {
                    const candidates = possibleNumberGrid[rowIndex][colIndex];
                    for (let i = 0; i < SUDOKU_SIZE; i++) {
                        if (i !== colIndex && candidates.some(num => possibleNumberGrid[rowIndex][i].includes(num))) {
                            newReferenceGrid[rowIndex][colIndex].push([rowIndex, i]);
                        }
                        if (i !== rowIndex && candidates.some(num => possibleNumberGrid[i][colIndex].includes(num))) {
                            newReferenceGrid[rowIndex][colIndex].push([i, colIndex]);
                        }
                    }
                    const startRow = rowIndex - rowIndex % BOX_SIZE;
                    const startCol = colIndex - colIndex % BOX_SIZE;
                    for (let r = 0; r < BOX_SIZE; r++) {
                        for (let c = 0; c < BOX_SIZE; c++) {
                            const value = possibleNumberGrid[startRow + r][startCol + c];
                            if (value.some(num => candidates.includes(num)) && (startRow + r !== rowIndex || startCol + c !== colIndex)) {
                                newReferenceGrid[rowIndex][colIndex].push([startRow + r, startCol + c]);
                            }
                        }
                    }
                }
            }
        }

        return newReferenceGrid;
    }
        // console.log($possibleNumberGrid)
    newPossibleNumberGrid = processNakedPairs(newPossibleNumberGrid);
    // console.log(newPossibleNumberGrid)
    newReferenceGrid = updateReferenceGrid(newPossibleNumberGrid);
    
    return [ newPossibleNumberGrid, newReferenceGrid,"NakedPairs"];
}

export function HiddenPairs(possibleNumberGrid){

    let newPossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid));

    let newReferenceGrid = [
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
	];

    // 用于找到单元格中的隐藏对
    function findHiddenPairsInUnit(unitCells, newPossibleNumberGrid) {
        // 用于记录每个候选数字出现的位置
        let candidatePositions = new Map();

        let temp = [
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
            [[], [], [], [], [], [], [], [], []],
        ];


        // 遍历单元格，记录每个数字在哪些格子中是候选数字
        unitCells.forEach(([row, col]) => {
            if (newPossibleNumberGrid[row][col].length > 0) {  // 只处理空格子
                newPossibleNumberGrid[row][col].forEach(num => {
                    if (!candidatePositions.has(num)) {
                        candidatePositions.set(num, [[row, col]]);
                    } else {
                        candidatePositions.get(num).push([row, col]);
                }
            });
            }
        });

                // 查找隐藏对（出现两次的候选数字）
        candidatePositions.forEach((positions, num) => {
            if (positions.length === 2) {
                positions.forEach(([row, col]) => {
                    // 只保留这个隐藏对的数字
                    temp[row][col].push(num)
                });
            }
        });
        
        unitCells.forEach(([row, col]) => {
            if (temp[row][col].length == 2) {
                newPossibleNumberGrid[row][col].length = 0
                temp[row][col].forEach(num => {
                    newPossibleNumberGrid[row][col].push(num);
            });
            }
        });

        return newPossibleNumberGrid;

    }
    

        // 对每一行、列和3x3小方格应用 Hidden Pairs 策略
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            // 对第i行处理
            const rowCells = Array.from({ length: SUDOKU_SIZE }, (_, col) => [i, col]);
            newPossibleNumberGrid = findHiddenPairsInUnit(rowCells,newPossibleNumberGrid);
            // 对第i列处理
            const colCells = Array.from({ length: SUDOKU_SIZE }, (_, row) => [row, i]);
            newPossibleNumberGrid =  findHiddenPairsInUnit(colCells,newPossibleNumberGrid);

            // 对第i个3x3小方格处理
            const startRow = Math.floor(i / BOX_SIZE) * BOX_SIZE;
            const startCol = (i % BOX_SIZE) * BOX_SIZE;
            const boxCells = [];
            for (let r = 0; r < BOX_SIZE; r++) {
                for (let c = 0; c < BOX_SIZE; c++) {
                    boxCells.push([startRow + r, startCol + c]);
                }
            }
            newPossibleNumberGrid = findHiddenPairsInUnit(boxCells,newPossibleNumberGrid);
        }

    return [newPossibleNumberGrid, newReferenceGrid, "HiddenPairs"];
    
}

export function XWing(possibleNumberGrid){

    let newPossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid));

    let newreferencegrid = Array.from({ length: SUDOKU_SIZE }, () => Array.from({ length: SUDOKU_SIZE }, () => [])); // 初始化三维数组

    // 遍历 1 到 9 的数字
    for (let num = 1; num <= 9; num++) {
        // 查找符合 X-Wing 条件的行对
        for (let row1 = 0; row1 < SUDOKU_SIZE; row1++) {
            for (let row2 = row1 + 1; row2 < SUDOKU_SIZE; row2++) {
                let cols1 = [];
                let cols2 = [];

                // 查找该行中含有 num 的候选位置
                for (let col = 0; col < SUDOKU_SIZE; col++) {
                    if (possibleNumberGrid[row1][col].includes(num)) {
                        cols1.push(col);
                    }
                    if (possibleNumberGrid[row2][col].includes(num)) {
                        cols2.push(col);
                    }
                }

                // 如果行1和行2中，num的候选列数都正好为2，且这两个列集合相等，说明找到了 X-Wing 模式
                if (cols1.length === 2 && cols2.length === 2 && cols1.toString() === cols2.toString()) {
                    // 应用 X-Wing 排除策略
                    for (let r = 0; r < 9; r++) {
                        if (r !== row1 && r !== row2) {
                            cols1.forEach(col => {
                                if (newPossibleNumberGrid[r][col].includes(num)) {
                                    newPossibleNumberGrid[r][col] = newPossibleNumberGrid[r][col].filter(val => val !== num);
                                    // 记录参考坐标
                                    newreferencegrid[r][col].push([row1, col]);
                                    newreferencegrid[r][col].push([row2, col]);
                                }
                            });
                        }
                    }
                }
            }
        }

        // 查找符合 X-Wing 条件的列对
        for (let col1 = 0; col1 < SUDOKU_SIZE; col1++) {
            for (let col2 = col1 + 1; col2 < SUDOKU_SIZE; col2++) {
                let rows1 = [];
                let rows2 = [];

                // 查找该列中含有 num 的候选位置
                for (let row = 0; row < SUDOKU_SIZE; row++) {
                    if (possibleNumberGrid[row][col1].includes(num)) {
                        rows1.push(row);
                    }
                    if (possibleNumberGrid[row][col2].includes(num)) {
                        rows2.push(row);
                    }
                }

                // 如果列1和列2中，num的候选行数都正好为2，且这两个行集合相等，说明找到了 X-Wing 模式
                if (rows1.length === 2 && rows2.length === 2 && rows1.toString() === rows2.toString()) {
                    // 应用 X-Wing 排除策略
                    for (let c = 0; c < SUDOKU_SIZE; c++) {
                        if (c !== col1 && c !== col2) {
                            rows1.forEach(row => {
                                if (newPossibleNumberGrid[row][c].includes(num)) {
                                    newPossibleNumberGrid[row][c] = newPossibleNumberGrid[row][c].filter(val => val !== num);
                                    // 记录参考坐标
                                    newreferencegrid[row][c].push([row, col1]);
                                    newreferencegrid[row][c].push([row, col2]);
                                }
                            });
                        }
                    }
                }
            }
        }
    }


    return [newPossibleNumberGrid, newreferencegrid, "XWing"];    
}

export function YWing(possibleNumberGrid){
    let newpossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid));

    let newreferencegrid = Array.from({ length: SUDOKU_SIZE }, () => Array.from({ length: SUDOKU_SIZE }, () => []));

    function IsSameArea(r1,c1,r2,c2){
        return ((Math.floor(r1 / BOX_SIZE) === Math.floor(r2 / BOX_SIZE) && Math.floor(c1 / BOX_SIZE) === Math.floor(c2 / BOX_SIZE)) || (r1 === r2 || c1 === c2) && !(r1 === r2 && c1 === c2));
    }

    for (let num = 1; num <= 9; num++) {
        // 查找符合 Y-Wing 条件的中心单元格
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (possibleNumberGrid[row][col].length === 2 && possibleNumberGrid[row][col].includes(num)) {
                    // 中心单元格的候选值
                    let candidates = possibleNumberGrid[row][col];
                    let remainingValue = candidates.find(c => c !== num); // 获取与num不同的候选值

                    // 寻找符合条件的端点单元格
                    for (let r1 = 0; r1 < 9; r1++) {
                        for (let c1 = 0; c1 < 9; c1++) {
                            // 端点单元格1，它的候选值应为 "A" 和 "C"
                            if ((IsSameArea(row,col,r1,c1)) && possibleNumberGrid[r1][c1].length === 2 && (possibleNumberGrid[r1][c1].includes(remainingValue))) {
                                let otherCandidates1 = possibleNumberGrid[r1][c1];
                                let commonValue = otherCandidates1.find(c => c !== remainingValue); // 获取剩下的候选值

                                for (let r2 = 0; r2 < 9; r2++) {
                                    for (let c2 = 0; c2 < 9; c2++) {
                                        // 端点单元格2，它的候选值应为 "B" 和 "C"
                                        if ((IsSameArea(row,col,r2,c2)) && (r2 !== r1 && c2 !== c1) && (!IsSameArea(r1,c1,r2,c2)) && possibleNumberGrid[r2][c2].length === 2 && possibleNumberGrid[r2][c2].includes(num) && possibleNumberGrid[r2][c2].includes(commonValue)) {
                                            
                                            {
                                                // 计算这两个端点单元格所在的 box 区域
                                                let box1RowStart = Math.floor(r1 / BOX_SIZE) * BOX_SIZE;
                                                let box2RowStart = Math.floor(r2 / BOX_SIZE) * BOX_SIZE;
                                                let box1ColStart = Math.floor(c1 / BOX_SIZE) * BOX_SIZE;
                                                let box2ColStart = Math.floor(c2 / BOX_SIZE) * BOX_SIZE;

                                                // 计算共同的 box 区域,不包含中心单元格
                                                let boxcommon1RowStart = Math.max(box1RowStart, box2RowStart);
                                                let boxcommon2RowStart = Math.min(box1RowStart,box2RowStart)
                                                let boxcommon1ColStart = Math.max(box1ColStart, box2ColStart);
                                                let boxcommon2ColStart = Math.min(box1ColStart,box2ColStart)

                                               let boxcommonRowStart,boxcommonColStart;

                                               if((boxcommon1RowStart === Math.floor(row / BOX_SIZE) * BOX_SIZE) && (boxcommon1ColStart === Math.floor(col / BOX_SIZE) * BOX_SIZE)){
                                                boxcommonRowStart = boxcommon2RowStart;
                                                boxcommonColStart = boxcommon2ColStart;
                                            }else{
                                                boxcommonRowStart = boxcommon1RowStart;
                                                boxcommonColStart = boxcommon1ColStart;
                                            }


                                                // 排除共享候选值C在box区域内的所有出现，且不包含中心单元格
                                                for (let i = boxcommonRowStart; i < boxcommonRowStart + BOX_SIZE; i++) {
                                                    for (let j = boxcommonColStart; j < boxcommonColStart + BOX_SIZE; j++) {
                                                        // 在 box 区域内排除共享值 C，且不包含中心单元格
                                                            if((i != r1 || j != c1) && (i != r2 || j != c2) && newpossibleNumberGrid[i][j].includes(commonValue
                                                            )){
                                                                newpossibleNumberGrid[i][j] = newpossibleNumberGrid[i][j].filter(val => val != commonValue);
                                                                newreferencegrid[i][j].push([r1, c1], [r2, c2],[row,col]); // 记录参考坐标
                                                            }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }


    return [newpossibleNumberGrid, newreferencegrid, "YWing"];
}

export function NakedTriples(possibleNumberGrid){
    let newpossibleNumberGrid = JSON.parse(JSON.stringify(possibleNumberGrid)); // 深拷贝
    let newreferencegrid = Array.from({ length: 9 }, () => Array.from({ length: 9 }, () => [])); // 初始化三维数组

// 辅助函数：用于排除某些值
    function excludeCandidatesInCells(cells, excludedValues, grid) {
        cells.forEach(cell => {
            let { row, col } = cell;
            let currentCandidates = grid[row][col];
            let updatedCandidates = currentCandidates.filter(c => !excludedValues.includes(c));
            if (updatedCandidates.length !== currentCandidates.length) {
                grid[row][col] = updatedCandidates;
                newreferencegrid[row][col].push(...cells.map(cell => [cell.row, cell.col]));
            }
        });
    }

    // 检查每个宫格内的裸三元组
    for (let boxRow = 0; boxRow < 3; boxRow++) {
        for (let boxCol = 0; boxCol < 3; boxCol++) {
            let cells = [];
            
            // 遍历当前宫格内的所有单元格
            for (let row = boxRow * 3; row < (boxRow + 1) * 3; row++) {
                for (let col = boxCol * 3; col < (boxCol + 1) * 3; col++) {
                    if (possibleNumberGrid[row][col].length <= 3) {
                        cells.push({ row, col, candidates: possibleNumberGrid[row][col] });
                    }
                }
            }

            // 如果发现 3 个候选值长度 <= 3 的单元格
            if (cells.length === 3) {
                let candidateSet = new Set();
                cells.forEach(cell => cell.candidates.forEach(c => candidateSet.add(c)));

                // 如果候选值集合中恰好包含 3 个数字
                if (candidateSet.size === 3) {
                    let tripletValues = Array.from(candidateSet);

                    // 判断它们是否满足裸三元组的条件
                    // 它们应该是所在行、列或宫的唯一未确定单元格
                    let allOtherCellsFilled = cells.every(cell => possibleNumberGrid[cell.row].filter(c => c.length !== 1).length === 3);

                    if (allOtherCellsFilled) {
                        // 1. 对所在宫内其他单元格排除这些候选值
                        let boxCells = [];
                        for (let r = boxRow * 3; r < (boxRow + 1) * 3; r++) {
                            for (let c = boxCol * 3; c < (boxCol + 1) * 3; c++) {
                                if (!cells.some(cell => cell.row === r && cell.col === c) && possibleNumberGrid[r][c].length > 1) {
                                    boxCells.push({ row: r, col: c });
                                }
                            }
                        }
                        excludeCandidatesInCells(boxCells, tripletValues, newpossibleNumberGrid);

                        // 2. 判断它们是否是行裸三元组或列裸三元组
                        let rows = cells.map(cell => cell.row);
                        let cols = cells.map(cell => cell.col);

                        // 如果它们在同一行（行裸三元组）
                        if (new Set(rows).size === 1) {
                            let row = rows[0];
                            // 排除该行内其他单元格的候选值
                            for (let col = 0; col < 9; col++) {
                                if (!cols.includes(col)) {
                                    let currentCandidates = newpossibleNumberGrid[row][col];
                                    let updatedCandidates = currentCandidates.filter(c => !tripletValues.includes(c));
                                    if (updatedCandidates.length !== currentCandidates.length) {
                                        newpossibleNumberGrid[row][col] = updatedCandidates;
                                        newreferencegrid[row][col].push(...cells.map(cell => [cell.row, cell.col]));
                                    }
                                }
                            }
                        }

                        // 如果它们在同一列（列裸三元组）
                        if (new Set(cols).size === 1) {
                            let col = cols[0];
                            // 排除该列内其他单元格的候选值
                            for (let row = 0; row < 9; row++) {
                                if (!rows.includes(row)) {
                                    let currentCandidates = newpossibleNumberGrid[row][col];
                                    let updatedCandidates = currentCandidates.filter(c => !tripletValues.includes(c));
                                    if (updatedCandidates.length !== currentCandidates.length) {
                                        newpossibleNumberGrid[row][col] = updatedCandidates;
                                        newreferencegrid[row][col].push(...cells.map(cell => [cell.row, cell.col]));
                                    }
                                }
                            }
                        }

                        // 3. 如果它们是宫内裸三元组，但不在同一行或同一列，则排除它们所在宫外的候选值
                        if (new Set(rows).size !== 1 && new Set(cols).size !== 1) {
                            // 这里只需要排除所在宫的其他单元格中的候选值，已在上一步完成
                        }
                    }
                }
            }
        }
    }
    return [newpossibleNumberGrid, newreferencegrid, "NakedTriples"];

}
