import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
import { referenceGrid,userGrid,PossibleNumberGrid } from '@sudoku/stores/grid'

//根据行、列、box获得可能的单元格的值
export function PossibleNumber(){
    // Helper function to get all numbers in a row
    function getRow(sudoku, row) {
        return sudoku[row];
    }

    // Helper function to get all numbers in a column
    function getCol(sudoku, col) {
        return sudoku.map(row => row[col]);
    }

    // Helper function to get all numbers in a 3x3 box
    function getBox(sudoku, row, col) {
        const box = [];
        const startRow = row - row % BOX_SIZE;
        const startCol = col - col % BOX_SIZE;
        for (let r = 0; r < BOX_SIZE; r++) {
            for (let c = 0; c < BOX_SIZE; c++) {
                box.push(sudoku[startRow + r][startCol + c]);
            }
        }
        return box;
    }

    function getPossibleNumbers(sudoku, row, col) {
        const usedNumbers = new Set([
            ...getRow(sudoku, row),
            ...getCol(sudoku, col),
            ...getBox(sudoku, row, col)
        ]);
        const possibleNumbers = [];
        for (let num = 1; num <= SUDOKU_SIZE; num++) {
            if (!usedNumbers.has(num)) {
                possibleNumbers.push(num);
            }
        }
        return possibleNumbers;
    }

    function getReferenceGrid(sudoku,rowIndex, colIndex){
        //row
        for (let num = 1; num <= SUDOKU_SIZE; num++) {
            if (sudoku[rowIndex][num] != 0) {
                referenceGrid.add([rowIndex,colIndex],[rowIndex,num])
            }
        } 

        //col
        for (let num = 1; num <= SUDOKU_SIZE; num++) {
            if (sudoku[num][colIndex] != 0) {
                referenceGrid.add([rowIndex,colIndex],[num,colIndex])
            }
        } 

        //box
        const startRow = rowIndex - rowIndex % BOX_SIZE;
        const startCol = colIndex - colIndex % BOX_SIZE;
        for (let r = 0; r < BOX_SIZE; r++) {
            for (let c = 0; c < BOX_SIZE; c++) {
            const value = sudoku[startRow + r][startCol + c];
            if (value !== 0) {
                referenceGrid.add([rowIndex, colIndex], [startRow + r, startCol + c]);
            }
            }
        }

    }

    userGrid.subscribe($userGrid=>{

        let newPossibleGrid = $userGrid.map((row, rowIndex) =>
            row.map((cell, colIndex) => {
                if (cell === 0) {
                    return getPossibleNumbers($userGrid, rowIndex, colIndex);
                } else {
                    return [];
                }
            })
        );

        newPossibleGrid.forEach((row, rowIndex) => {
            row.forEach((cell, colIndex) => {
            if (cell.length > 0) {
                getReferenceGrid(newPossibleGrid, $userGrid, rowIndex, colIndex);
            }
            });
        });

    })
}



//两个单元格中的两个候选数的集合，它们至少共属于一个单元。
export function NakedPairs(){
    function findNakedPairs(cells) {
        const pairs = [];
        const pairMap = new Map();

        cells.forEach((cell, index) => {
            if (cell.length === 2) {
                const key = cell.join(',');
                if (pairMap.has(key)) {
                    pairs.push([pairMap.get(key), index]);
                } else {
                    pairMap.set(key, index);
                }
            }
        });

        return pairs;
    }

    function removeNakedPairs(cells, pairs) {
        pairs.forEach(([index1, index2]) => {
            const [num1, num2] = cells[index1];
            cells.forEach((cell, index) => {
                if (index !== index1 && index !== index2) {
                    const newCell = cell.filter(num => num !== num1 && num !== num2);
                    cells[index] = newCell;
                }
            });
        });
    }

    function processNakedPairs(grid) {
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            // 行
            const row = grid[i];
            const rowPairs = findNakedPairs(row);
            removeNakedPairs(row, rowPairs);

            // 列
            const col = grid.map(row => row[i]);
            const colPairs = findNakedPairs(col);
            removeNakedPairs(col, colPairs);

            // 宫格
            const box = [];
            const startRow = Math.floor(i / BOX_SIZE) * BOX_SIZE;
            const startCol = (i % BOX_SIZE) * BOX_SIZE;
            for (let r = 0; r < BOX_SIZE; r++) {
                for (let c = 0; c < BOX_SIZE; c++) {
                    box.push(grid[startRow + r][startCol + c]);
                }
            }
            const boxPairs = findNakedPairs(box);
            removeNakedPairs(box, boxPairs);
        }
    }

    PossibleNumberGrid.subscribe($possibleNumberGrid => {
        let newPossibleGrid = $possibleNumberGrid.map((row, rowIndex) =>
            row.map((cell, colIndex) => {
                if (cell.length > 0) {
                    return getPossibleNumbers($possibleNumberGrid, rowIndex, colIndex);
                } else {
                    return [];
                }
            })
        );

        processNakedPairs(newPossibleGrid);
        PossibleNumberGrid.set(newPossibleGrid);
    });

}