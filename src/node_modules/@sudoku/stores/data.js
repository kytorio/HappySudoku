import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { userGrid } from './grid';
import { gameRecall,gameBackWard,gameForward } from './game'
import { writable } from 'svelte/store';
import { encodeSudoku,decodeSencode } from '../sencode/index'
import { cursor } from '@sudoku/stores/cursor';	
import { subscribe } from 'svelte/internal';

export const ReCallData = writable([])
export const BackupStack = writable([])
export const ForwardStack = writable([])

//生成可回溯序列
export function createReCalldata(userGrid){
    let newGrid = [];

	for (let y = 0; y < SUDOKU_SIZE; y++) {
		newGrid[y] = [];
		for (let x = 0; x < SUDOKU_SIZE; x++) {
			newGrid[y][x] = userGrid[y][x];
		}
	}
    ReCallData.update(stack => {
        stack.push(newGrid);
        return stack;
    })

    gameRecall.set(true);
    
    
}

export function decodeReCallData(){

    ReCallData.update(stack => {
        if (stack.length > 0) {
            const newGrid = stack.pop();
            for (let y = 0; y < SUDOKU_SIZE; y++) {
                for (let x = 0; x < SUDOKU_SIZE; x++) {
                    userGrid.set({ y, x }, newGrid[y][x]);
                    BackupData.clear();
                    ForwardData.clear();
                }
            }
            if (stack.length === 0) {
                gameRecall.set(false);
            }
        }
        return stack;
    });
}

function createBackupData(){

    return {
        subscribe: BackupStack.subscribe,

        add: (pos, value) =>{
            BackupStack.update($BackupStack => {
                $BackupStack.push({pos, value});
                return $BackupStack;
            });
            gameBackWard.set(true);
        },

        clear: () => {
            BackupStack.set([]);
            gameBackWard.set(false);
        }
    }

}

export const BackupData = createBackupData();

export function decodeBackupData(){
    BackupStack.update(stack => {
        if (stack.length > 0) {
            const data = stack.pop();
            ForwardData.add(data.pos,data.value);
            for (let y = 0; y < SUDOKU_SIZE; y++) {
                for (let x = 0; x < SUDOKU_SIZE; x++) {
                    userGrid.set(data.pos, 0);
                }
            }
            if (stack.length === 0) {
                gameBackWard.set(false);
            }
        }
        return stack;
    });
}

export function createForwardData(){
    return {
        subscribe: BackupStack.subscribe,

        add: (pos, value) =>{
            ForwardStack.update($ForwardStack => {
                $ForwardStack.push({pos, value});
                return $ForwardStack;
            });
            gameForward.set(true);
        },

        clear: () => {
            ForwardStack.set([]);
            gameForward.set(false);
        }

    }
}

export const ForwardData = createForwardData();

export function decodeForwardData(){
    ForwardStack.update($ForwardStack => {
        if ($ForwardStack.length > 0) {
            const data = $ForwardStack.pop();
            for (let y = 0; y < SUDOKU_SIZE; y++) {
                for (let x = 0; x < SUDOKU_SIZE; x++) {
                    userGrid.set(data.pos, data.value);
                }
            }
            if ($ForwardStack.length === 0) {
                gameForward.set(false);
            }
        }
        return $ForwardStack;
    });
}

