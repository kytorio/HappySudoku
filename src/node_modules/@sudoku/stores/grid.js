import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
import { derived, writable } from 'svelte/store';
import { hints } from './hints';

//创建题目
function createGrid() {
	const grid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	return {
		subscribe: grid.subscribe,

		generate(difficulty) {	//根据难度生成数独
			grid.set(generateSudoku(difficulty));
		},

		decodeSencode(sencode) {	//解码数独链接
			grid.set(decodeSencode(sencode));
		},

		get(gridStore, x, y) {
			return gridStore[y][x];
		},

		getSencode(gridStore) {
			return encodeSudoku(gridStore);
		},
	};
}

export const grid = createGrid();


function createUserGrid() {
	const userGrid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	grid.subscribe($grid => {
		let newGrid = [];

		for (let y = 0; y < SUDOKU_SIZE; y++) {
			newGrid[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				newGrid[y][x] = $grid[y][x];
			}
		}

		userGrid.set(newGrid);
	});

	return {
		subscribe: userGrid.subscribe,

		set: (pos, value) => {
			userGrid.update($userGrid => {
				// console.log(pos.y, pos.x, value);
				$userGrid[pos.y][pos.x] = value;
				return $userGrid;
			});
		},

		getRow: (rowIndex) => {
			let row = [];
			userGrid.subscribe($userGrid => {
				row = $userGrid[rowIndex];
			});
			return row;
		},

		getCol: (colIndex) => {
			let col = [];
			userGrid.subscribe($userGrid => {
				for (let i = 0; i < SUDOKU_SIZE; i++) {
					col.push($userGrid[i][colIndex]);
				}
			});
			return col;
		},

		getBox: (rowIndex,colIndex) => {
			let box = [];
			const startY = rowIndex - rowIndex % BOX_SIZE;
			const startX = colIndex - colIndex % BOX_SIZE;
			userGrid.subscribe($userGrid => {
				for (let y = startY; y < startY + BOX_SIZE; y++) {
					for (let x = startX; x < startX + BOX_SIZE; x++) {
						box.push($userGrid[y][x]);
					}
				}
			});
			return box;
		}
		// applyHint: (pos) => {	//应用提示，没有应用策略，直接更新为数独答案
		// 	hints.useHint();
		// 	userGrid.update($userGrid => {
		// 		const solvedSudoku = solveSudoku($userGrid);
		// 		$userGrid[pos.y][pos.x] = solvedSudoku[pos.y][pos.x];
		// 		return $userGrid;
		// 	});
		// },
	};
}

export const userGrid = createUserGrid();


// function createHintGrid() {
// 	const hintGrid = writable([
// 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
// 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
// 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
// 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
// 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
// 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
// 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
// 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
// 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
// 	]);

// 	userGrid.subscribe($userGrid => {
// 		let newGrid = [];

// 		for (let y = 0; y < SUDOKU_SIZE; y++) {
// 			newGrid[y] = [];
// 			for (let x = 0; x < SUDOKU_SIZE; x++) {
// 				newGrid[y][x] = $userGrid[y][x];
// 			}
// 		}

// 		hintGrid.set(newGrid);
// 	});

// 	return {
// 		subscribe: hintGrid.subscribe,

// 		set: (pos, value) => {
// 			hintGrid.update($hintGrid => {
// 				$hintGrid[pos.y][pos.x] = value;
// 				return $hintGrid;
// 			});
// 		},

// 		clear: (pos) => {
// 			hintGrid.update($hintGrid => {
// 				delete $hintGrid[pos.y][pos.x];
// 				return $hintGrid;
// 			});
// 		}
// 	};
// }

// export const hintGrid = createHintGrid();

function createPossibleNumberGrid() {
	const PossibleNumberGrid = writable([
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
	]);

	return {
		subscribe: PossibleNumberGrid.subscribe,

		set: (pos, value) => {
			PossibleNumberGrid.update($referenceGrid => {
				$referenceGrid[pos.y][pos.x] = value;
				return $referenceGrid;
			});
		},

		clear: (pos) => {
			PossibleNumberGrid.update($referenceGrid => {
				$referenceGrid[pos.y][pos.x] = [];
				return $referenceGrid;
			});
		}
	};
}

export const PossibleNumberGrid = createPossibleNumberGrid();


function createReferenceGrid() {
	const referenceGrid = writable([
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
	]);

	return {
		subscribe: referenceGrid.subscribe,

		set: (pos, value) => {
			referenceGrid.update($referenceGrid => {
				$referenceGrid[pos.y][pos.x] = value;
				return $referenceGrid;
			});
		},

		clear: (pos) => {
			referenceGrid.update($referenceGrid => {
				$referenceGrid[pos.y][pos.x] = [];
				return $referenceGrid;
			});
		},

		add: (pos,value) =>{
			referenceGrid.update($referenceGrid => {
				$referenceGrid[pos.y][pos.x].push(value);
				return $referenceGrid;
			});
		}
	};
}

export const referenceGrid = createReferenceGrid();


function createStrategyGrid() {
	const strategyGrid = writable([
		["", "", "", "", "", "", "", "", ""],
		["", "", "", "", "", "", "", "", ""],
		["", "", "", "", "", "", "", "", ""],
		["", "", "", "", "", "", "", "", ""],
		["", "", "", "", "", "", "", "", ""],
		["", "", "", "", "", "", "", "", ""],
		["", "", "", "", "", "", "", "", ""],
		["", "", "", "", "", "", "", "", ""],
		["", "", "", "", "", "", "", "", ""],
	]);

	return {
		subscribe: strategyGrid.subscribe,

		set: (pos, value) => {
			strategyGrid.update($strategyGrid => {
				$strategyGrid[pos.y][pos.x] = value;
				return $strategyGrid;
			});
		},

		clear: (pos) => {
			strategyGrid.update($strategyGrid => {
				$strategyGrid[pos.y][pos.x] = "";
				return $strategyGrid;
			});
		}
	};
}

export const strategyGrid = createStrategyGrid();


function createStrategyContent() {
	const content = writable((() => {
		return [];
	})());

	return {
		subscribe: content.subscribe,

		set(newContent) {
			content.set(newContent);
		},

		clear: () => {
			content.set([]);
		}
	};
}

export const strategyContent = createStrategyContent();


//根据用户输入的数独，返回冲突的单元格
export const invalidCells = derived(userGrid, $userGrid => {
	const _invalidCells = [];

	const addInvalid = (x, y) => {
		const xy = x + ',' + y;
		if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
	};

	for (let y = 0; y < SUDOKU_SIZE; y++) {
		for (let x = 0; x < SUDOKU_SIZE; x++) {

			const value = $userGrid[y][x];

			if (value) {
				for (let i = 0; i < SUDOKU_SIZE; i++) {
					// Check the row
					if (i !== x && $userGrid[y][i] === value) {
						addInvalid(x, y);
					}

					// Check the column
					if (i !== y && $userGrid[i][x] === value) {
						addInvalid(x, i);
					}
				}

				// Check the box
				const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
				const endY = startY + BOX_SIZE;
				const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
				const endX = startX + BOX_SIZE;
				for (let row = startY; row < endY; row++) {
					for (let col = startX; col < endX; col++) {
						if (row !== y && col !== x && $userGrid[row][col] === value) {
							addInvalid(col, row);
						}
					}
				}
			}

		}
	}

	return _invalidCells;
}, []);