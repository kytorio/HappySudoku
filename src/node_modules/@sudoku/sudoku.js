import solve from '@mattflow/sudoku-solver';
import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
import { getSudoku } from 'fake-sudoku-puzzle-generator';


/**
 * @param {('veryeasy' | 'easy' | 'medium' | 'hard')} difficulty
 * @returns {number[][]}
 */
export function generateSudoku(difficulty = 'easy') {	//通过外部模块fake-sudoku-puzzle进行生成
	const sudoku = getSudoku(difficulty);

	for (let row = 0; row < SUDOKU_SIZE; row++) {
		for (let col = 0; col < SUDOKU_SIZE; col++) {
			if (sudoku[row][col] === null) sudoku[row][col] = 0;
		}
	}

	return sudoku;
}

// 和策略应用衔接的地方，输入是当前$userGrid（即下面的形参sudoku），输出每个单元格（用户可以填的单元格，后同）的可能值、每个单元格参考的单位格的坐标、每个单元格的策略
export function solveSudokuTest(sudoku) {
    const size = 9;
    const boxSize = 3;

    // Helper function to get all numbers in a row
    function getRow(sudoku, row) {
        return sudoku[row];
    }

    // Helper function to get all numbers in a column
    function getCol(sudoku, col) {
        return sudoku.map(row => row[col]);
    }

    // Helper function to get all numbers in a 3x3 box
    function getBox(sudoku, row, col) {
        const box = [];
        const startRow = row - row % boxSize;
        const startCol = col - col % boxSize;
        for (let r = 0; r < boxSize; r++) {
            for (let c = 0; c < boxSize; c++) {
                box.push(sudoku[startRow + r][startCol + c]);
            }
        }
        return box;
    }

    // Helper function to get possible numbers for a cell
    function getPossibleNumbers(sudoku, row, col) {
        const usedNumbers = new Set([
            ...getRow(sudoku, row),
            ...getCol(sudoku, col),
            ...getBox(sudoku, row, col)
        ]);
        const possibleNumbers = [];
        for (let num = 1; num <= size; num++) {
            if (!usedNumbers.has(num)) {
                possibleNumbers.push(num);
            }
        }
        return possibleNumbers;
    }

    // Iterate through the sudoku array and find possible numbers for each empty cell
    const possibleNumbersGrid = sudoku.map((row, rowIndex) =>
        row.map((cell, colIndex) => {
            if (cell === 0) {
                return getPossibleNumbers(sudoku, rowIndex, colIndex);
            } else {
                return [];
            }
        })
    );

    const referenceNumbersGrid = sudoku.map((row, rowIndex) =>
        row.map((cell, colIndex) => {
            if (cell === 0) {
                const nonEmptyCells = [];
                for (let r = 0; r < SUDOKU_SIZE; r++) {
                    for (let c = 0; c < SUDOKU_SIZE; c++) {
                        if (sudoku[r][c] !== 0) {
                            nonEmptyCells.push([r, c]);
                        }
                    }
                }
                const randomIndices = [];
                while (randomIndices.length < 2) {
                    const randomIndex = Math.floor(Math.random() * nonEmptyCells.length);
                    if (!randomIndices.includes(randomIndex)) {
                        randomIndices.push(randomIndex);
                    }
                }
                return [nonEmptyCells[randomIndices[0]], nonEmptyCells[randomIndices[1]]];
            } else {
                return [];
            }
        })
    );

	const strategyGrid = sudoku.map((row, rowIndex) =>
        row.map((cell, colIndex) => {
            if (cell === 0) {
                return ["strategy1", "strategy2"];
            } else {
                return [];
            }
        })
    );

    return [possibleNumbersGrid, referenceNumbersGrid, strategyGrid];
}


/**
 * @param {number[][]} sudoku
 */
export function solveSudoku(sudoku) {
	let grid = [
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	];

	const solution = solve(sudoku.flat().join(''), {	//通过外部模块sudoku-slover进行数独解的生成
		outputArray: true,
		hintCheck: false
	});

	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		const [row, col] = GRID_COORDS[cell];	//坐标
		grid[row][col] = solution[cell];
	}

	return grid;
}


/**
 * @param {number[][]} sudoku
 */
export function printSudoku(sudoku) {
	let out = '╔═══════╤═══════╤═══════╗\n';

	for (let row = 0; row < SUDOKU_SIZE; row++) {
		if (row !== 0 && row % BOX_SIZE === 0) {
			out += '╟───────┼───────┼───────╢\n';
		}

		for (let col = 0; col < SUDOKU_SIZE; col++) {
			if (col === 0) {
				out += '║ ';
			} else if (col % BOX_SIZE === 0) {
				out += '│ ';
			}

			out += (sudoku[row][col] === 0 ? '·' : sudoku[row][col]) + ' ';

			if (col === SUDOKU_SIZE - 1) {
				out += '║';
			}
		}

		out += '\n';
	}

	out += '╚═══════╧═══════╧═══════╝';

	console.log(out);
}
