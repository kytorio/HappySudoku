import solve from '@mattflow/sudoku-solver';
import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS, MAXLEVEL } from '@sudoku/constants';
import { getSudoku } from 'fake-sudoku-puzzle-generator';
import { strategyMap,strategyRegistry } from '@sudoku/stores/strategy'
import { PossibleNumberGrid,referenceGrid } from '@sudoku/stores/grid';
import { settings } from '@sudoku/stores/settings';

/**
 * @param {('veryeasy' | 'easy' | 'medium' | 'hard')} difficulty
 * @returns {number[][]}
 */
export function generateSudoku(difficulty = 'easy') {	//通过外部模块fake-sudoku-puzzle进行生成
	const sudoku = getSudoku(difficulty);

	for (let row = 0; row < SUDOKU_SIZE; row++) {
		for (let col = 0; col < SUDOKU_SIZE; col++) {
			if (sudoku[row][col] === null) sudoku[row][col] = 0;
		}
	}

	return sudoku;
}

// return possibleNumbersGrid referenceNumbersGrid strategyGrid
export function solveSudokuTest(sudoku) {
    let level = 0;
    settings.subscribe($settings => {
        level = $settings.minhintlevelateachstep;
    });

    // const strategyKeys = Array.from(strategyMap.keys());
    const strategyKeys = strategyRegistry.getStrategyKeys();
    // console.log(strategyKeys, strategyKeys.length);

    // let maxCellsBelowLevel = 0;
    let initialStrategyClass = strategyRegistry.getStrategy(strategyKeys[0]);
    let initialStrategy = new initialStrategyClass();
    let [initialPossibleGrid, initialReferenceGrid, initialStrategyName] = initialStrategy.execute();
    // let initialStrategyFunction = strategyMap.get(strategyKeys[0]);
    // let [initialPossibleGrid, initialReferenceGrid, initialStrategyName] = initialStrategyFunction();
    let maxCellsBelowLevel = initialPossibleGrid.flat().filter(cell => cell.length <= MAXLEVEL && cell.length > 0).length;
    let possibleNumbersGrid = initialPossibleGrid;
    let bestStrategyCombination = maxCellsBelowLevel > 0 ? [initialStrategyName] : [];

    function dfs(currentGrid, currentStrategyIndex, currentCombination) {
        if (currentStrategyIndex >= strategyKeys.length) {
            return;
        }

        for (let i = currentStrategyIndex; i < strategyKeys.length; i++) {
            let strategyKey = strategyKeys[i];
            let strategyClass = strategyRegistry.getStrategy(strategyKey);
            let strategy = new strategyClass();
            let [newPossibleGrid, newReferenceGrid, strategyName] = strategy.execute(currentGrid);
            // let strategyFunction = strategyMap.get(strategyKey);
            // let [newPossibleGrid, newReferenceGrid, strategyName] = strategyFunction(currentGrid);

            let cellsBelowLevel = newPossibleGrid.flat().filter(cell => cell.length <= MAXLEVEL && cell.length > 0).length;

            if (cellsBelowLevel > maxCellsBelowLevel) {
                maxCellsBelowLevel = cellsBelowLevel;
                bestStrategyCombination = [...currentCombination, strategyName];
                possibleNumbersGrid = newPossibleGrid;
            }

            dfs(newPossibleGrid, i + 1, [...currentCombination, strategyName]);
        }
    }

    dfs(initialPossibleGrid, 1, bestStrategyCombination);

    // console.log('Best Strategy Combination:', bestStrategyCombination);
    // console.log('Max Cells Below Level:', maxCellsBelowLevel);
    // console.log(possibleNumbersGrid);

    // 依次记录bestStrategyCombination里每个策略的possibleGrid和referenceGrid
    let prevPossibleGrid;
    let referenceGridMap = new Map();
    let possibleGridMap = new Map();
    for (let i = 0; i < bestStrategyCombination.length; i++) {
        let key = bestStrategyCombination[i];
        let strategyClass = strategyRegistry.getStrategy(key);
        let strategy = new strategyClass();

        let newPossibleGrid, newReferenceGrid, strategyName;
        if (key == "PossibleNumber") {
            // [newPossibleGrid, newReferenceGrid, strategyName] = strategyFunction();
            [newPossibleGrid, newReferenceGrid, strategyName] = strategy.execute();
        } else {
            [newPossibleGrid, newReferenceGrid, strategyName] = strategy.execute(prevPossibleGrid);
            // [newPossibleGrid, newReferenceGrid, strategyName] = strategyFunction(prevPossibleGrid);
        }
        // console.log(newReferenceGrid);
        prevPossibleGrid = newPossibleGrid;
        possibleGridMap.set(key, newPossibleGrid);
        referenceGridMap.set(key, newReferenceGrid);
    }

    const referenceNumbersGrid = sudoku.map((row, rowIndex) =>
        row.map((cell, colIndex) => {
            if (cell === 0 && possibleNumbersGrid[rowIndex][colIndex].length > 0) {
                let minKey = null;
                let minLength = Infinity;
                for (let [key, grid] of possibleGridMap) {
                    let length = grid[rowIndex][colIndex].length;
                    if (length < minLength) {
                        minLength = length;
                        minKey = key;
                    }
                }
                let collectedStrategies = [];
                for (let key of bestStrategyCombination) {
                    collectedStrategies.push(key);
                    if (key === minKey) break;
                }

                for (let i = collectedStrategies.length - 1; i >= 0; i--) {
                    let key = collectedStrategies[i];
                    let value = referenceGridMap.get(key)[rowIndex][colIndex];
                    if (value.length > 0) {
                        return value;
                    }
                }
                return [];
            } else {
                return [];
            }
        })
    );
    
    const strategyGrid = sudoku.map((row, rowIndex) =>
        row.map((cell, colIndex) => {
            if (cell === 0 && possibleNumbersGrid[rowIndex][colIndex].length > 0) {
                let minKey = null;
                let minLength = Infinity;
                for (let [key, grid] of possibleGridMap) {
                    let length = grid[rowIndex][colIndex].length;
                    if (length < minLength) {
                        minLength = length;
                        minKey = key;
                    }
                }
                let strategySequence = [];
                for (let key of bestStrategyCombination) {
                    strategySequence.push(key);
                    if (key === minKey) break;
                }
                return strategySequence;
            } else {
                return [];
            }
        })
    );
    // console.log(bestStrategyCombination);
    // console.log(possibleNumbersGrid);
    // console.log(referenceNumbersGrid);
    // console.log(strategyGrid);
    return [possibleNumbersGrid, referenceNumbersGrid, strategyGrid];
}


/**
 * @param {number[][]} sudoku
 */
export function solveSudoku(sudoku) {
	let grid = [
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	];

	const solution = solve(sudoku.flat().join(''), {	//通过外部模块sudoku-slover进行数独解的生成
		outputArray: true,
		hintCheck: false
	});

	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		const [row, col] = GRID_COORDS[cell];	//坐标
		grid[row][col] = solution[cell];
	}

	return grid;
}


/**
 * @param {number[][]} sudoku
 */
export function printSudoku(sudoku) {
	let out = '╔═══════╤═══════╤═══════╗\n';

	for (let row = 0; row < SUDOKU_SIZE; row++) {
		if (row !== 0 && row % BOX_SIZE === 0) {
			out += '╟───────┼───────┼───────╢\n';
		}

		for (let col = 0; col < SUDOKU_SIZE; col++) {
			if (col === 0) {
				out += '║ ';
			} else if (col % BOX_SIZE === 0) {
				out += '│ ';
			}

			out += (sudoku[row][col] === 0 ? '·' : sudoku[row][col]) + ' ';

			if (col === SUDOKU_SIZE - 1) {
				out += '║';
			}
		}

		out += '\n';
	}

	out += '╚═══════╧═══════╧═══════╝';

	console.log(out);
}
