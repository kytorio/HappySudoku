import { GRID_COORDS, GRID_LENGTH, SENCODE_REGEX, SENCODE_SEPARATOR as SEPARATOR, SENCODE_SEPARATOR_REVERSE as SEPARATOR_REVERSE } from '@sudoku/constants';
import Base62 from './base62';

//判断是否需要转置数独
/**
 * @param {number[]} flatGrid
 * @returns {boolean}
 */
function shouldReverse(flatGrid) {
	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		if (flatGrid[(GRID_LENGTH - 1) - cell] !== 0) {
			return false;
		} else if (flatGrid[cell] !== 0) {
			return true;
		}
	}

	return false;
}

//判断是否为有效的url
function isValidUrl(string) {
    const urlPattern = new RegExp('^(https?:\\/\\/)?' + // protocol
        '((([a-zA-Z\\d]([a-zA-Z\\d-]*[a-zA-Z\\d])*)\\.)+[a-zA-Z]{2,}|' + // domain name
        '((\\d{1,3}\\.){3}\\d{1,3}))' + // OR ip (v4) address
        '(\\:\\d+)?(\\/[-a-zA-Z\\d%_.~+]*)*' + // port and path
        '(\\?[;&a-zA-Z\\d%_.~+=-]*)?' + // query string
        '(\\#[-a-zA-Z\\d_]*)?$', 'i'); // fragment locator
	const parsedUrl = new URL(string);

    return urlPattern.test(string) && parsedUrl.hostname === 'www.sudokuwiki.org' && parsedUrl.searchParams.get('bd').length === GRID_LENGTH;
}

function extractDomainAndBd(url) {

	// 解析 URL
    const parsedUrl = new URL(url);

    // 提取域名
    const domain = parsedUrl.hostname;

    // 提取 bd 参数
    const bdParam = parsedUrl.searchParams.get('bd');

    return bdParam;
}

//编码数独，推测是用于生成url，大概是用在分享功能中
/**
 * @param {number[][]} sudoku
 * @returns {string}
 */
export function encodeSudoku(sudoku) {
	/** @type number[] */
	const flatGrid = sudoku.flat();

	const reversed = shouldReverse(flatGrid);
	if (reversed) {
		// Reverse sudoku array
		flatGrid.reverse();
	}

	let structure = '';
	let numbers = '';

	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		structure += (flatGrid[cell] === 0 ? '0' : '1');

		if (flatGrid[cell] > 0) {
			numbers += flatGrid[cell] - 1; // Subtract 1 so the number gets smaller
		}
	}

	return Base62.encode(BigInt('0b' + structure)) +
	       (reversed ? SEPARATOR_REVERSE : SEPARATOR) +
	       Base62.encode(BigInt(numbers));
}


/**
 * @param {string} sencode
 * @returns {number[][]}
 */

//将sencode解码为数独
export function decodeSencode(sencode) {
	let grid = [
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	];

	if (isValidUrl(sencode)) {

		const bd = extractDomainAndBd(sencode);
		for (let cell = 0; cell < GRID_LENGTH; cell++) {
			if(bd[cell] !== '0'){
				const [row, col] = GRID_COORDS[cell];
				grid[row][col] = bd[cell] * 1;
			}
		}

	}else{
		//判断是否存在分隔符_，存在则说明该数组为转置
		const reversed = sencode.indexOf(SEPARATOR_REVERSE) !== -1;

		const [encodedStructure, encodedNumbers] = sencode.split(reversed ? SEPARATOR_REVERSE : SEPARATOR);

		//分离数独网络中的结构信息，将结构信息转换为二进制字符串，1则对应该单元存在数字
		const structure = Base62.decode(encodedStructure)
								.toString(2)
								.padStart(GRID_LENGTH, '0');

		let numberCount = 0;
		for (let cell = 0; cell < GRID_LENGTH; cell++) {
			if (structure[cell] === '1') {
				numberCount++;
			}
		}
		
		//得到一个字符串
		let numbers = Base62.decode(encodedNumbers)
							.toString()
							.padStart(numberCount, '0')
							.split('');

		for (let cell = 0; cell < GRID_LENGTH; cell++) {
			if (structure[cell] === '1') {
				const [row, col] = GRID_COORDS[cell];
				grid[row][col] = numbers.shift() * 1 + 1;
			}
		}

		if (reversed) {
			// Reverse Grid
			grid = grid.reverse().map(row => row.reverse());
		}
	}	
	return grid;
}


/**
 * @param {string} sencode
 * @returns {boolean}
 */
export function validateSencode(sencode) {	//验证sencode是否合法
	//给定一个url，去除前面的域名，只保留后面的参数，然后判断是否符合正则表达式
	return sencode && sencode.trim().length !== 0 && (SENCODE_REGEX.test(sencode) || isValidUrl(sencode));
}